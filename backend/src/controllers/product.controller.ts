import { Request, Response } from 'express';
import prisma from '../lib/prisma';
import { generateEAN13 } from '../utils/barcode';
import * as XLSX from 'xlsx';

export const getAllProducts = async (req: Request, res: Response) => {
  try {
    const { search, categoryId, isActive } = req.query;

    const where: any = {};

    if (search) {
      where.OR = [
        { name: { contains: search as string } },
        { barcode: { contains: search as string } },
      ];
    }

    if (categoryId) {
      where.categoryId = categoryId as string;
    }

    if (isActive !== undefined) {
      where.isActive = isActive === 'true';
    }

    const products = await prisma.product.findMany({
      where,
      include: {
        category: true,
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    res.json({ products });
  } catch (error) {
    console.error('Get products error:', error);
    res.status(500).json({ error: '√úr√ºnler getirilemedi' });
  }
};

export const getProductById = async (req: Request, res: Response) => {
  try {
    const { id } = req.params;

    const product = await prisma.product.findUnique({
      where: { id },
      include: {
        category: true,
      },
    });

    if (!product) {
      return res.status(404).json({ error: '√úr√ºn bulunamadƒ±' });
    }

    res.json({ product });
  } catch (error) {
    console.error('Get product error:', error);
    res.status(500).json({ error: '√úr√ºn getirilemedi' });
  }
};

export const getProductByBarcode = async (req: Request, res: Response) => {
  try {
    let { barcode } = req.params;
    
    // üî• BARKOD NORMALƒ∞ZE ET (bo≈üluklarƒ± kaldƒ±r, b√ºy√ºk harf yap)
    const normalizedBarcode = barcode.trim().replace(/\s+/g, '').toUpperCase();

    // ƒ∞LK DENEME: Tam e≈üle≈üme (exact match)
    let product = await prisma.product.findUnique({
      where: { barcode },
      include: {
        category: true,
      },
    });

    // ƒ∞Kƒ∞NCƒ∞ DENEME: Normalize edilmi≈ü ile tam e≈üle≈üme
    if (!product) {
      product = await prisma.product.findUnique({
        where: { barcode: normalizedBarcode },
        include: {
          category: true,
        },
      });
    }

    // √ú√á√úNC√ú DENEME: CONTAINS search (i√ßerir)
    if (!product) {
      const products = await prisma.product.findMany({
        where: {
          barcode: {
            contains: normalizedBarcode,
          },
        },
        include: {
          category: true,
        },
        take: 1,
      });
      
      if (products.length > 0) {
        product = products[0];
      }
    }

    if (!product) {
      return res.status(404).json({ error: '√úr√ºn bulunamadƒ±' });
    }

    res.json(product); // üî• Direkt product objesini d√∂n
  } catch (error) {
    console.error('Get product by barcode error:', error);
    res.status(500).json({ error: '√úr√ºn getirilemedi' });
  }
};

export const createProduct = async (req: Request, res: Response) => {
  try {
    const { barcode, name, description, sellPrice, buyPrice, stock, unit, taxRate, minStock, categoryId, imageUrl } = req.body;

    // Barkod kontrol√º
    let finalBarcode = barcode;
    if (!finalBarcode) {
      finalBarcode = generateEAN13();
    }

    // Barkod benzersiz mi kontrol et
    const existingProduct = await prisma.product.findUnique({
      where: { barcode: finalBarcode },
    });

    if (existingProduct) {
      return res.status(400).json({ error: 'Bu barkod zaten kullanƒ±lƒ±yor' });
    }

    const product = await prisma.product.create({
      data: {
        barcode: finalBarcode,
        name,
        description,
        sellPrice: parseFloat(sellPrice),
        buyPrice: buyPrice ? parseFloat(buyPrice) : 0,
        stock: stock ? parseInt(stock) : 0,
        unit: unit || 'Adet',
        taxRate: taxRate ? parseFloat(taxRate) : 18,
        minStock: minStock ? parseInt(minStock) : 5,
        ...(categoryId && categoryId !== '' && { categoryId }),
        imageUrl,
      },
      include: {
        category: true,
      },
    });

    res.status(201).json({ message: '√úr√ºn ba≈üarƒ±yla olu≈üturuldu', product });
  } catch (error) {
    console.error('Create product error:', error);
    res.status(500).json({ error: '√úr√ºn olu≈üturulamadƒ±' });
  }
};

export const updateProduct = async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const { name, description, sellPrice, buyPrice, stock, unit, taxRate, minStock, categoryId, imageUrl, isActive, isFavorite } = req.body;

    // Update data objesini dinamik olarak olu≈ütur
    const updateData: any = {};
    
    if (name !== undefined) updateData.name = name;
    if (description !== undefined) updateData.description = description;
    if (sellPrice !== undefined) updateData.sellPrice = parseFloat(sellPrice);
    if (buyPrice !== undefined) updateData.buyPrice = parseFloat(buyPrice);
    if (stock !== undefined) updateData.stock = parseInt(stock);
    if (unit !== undefined) updateData.unit = unit;
    if (taxRate !== undefined) updateData.taxRate = parseFloat(taxRate);
    if (minStock !== undefined) updateData.minStock = parseInt(minStock);
    if (categoryId !== undefined) {
      // Bo≈ü string ise null yap
      updateData.categoryId = categoryId === '' ? null : categoryId;
    }
    if (imageUrl !== undefined) updateData.imageUrl = imageUrl;
    if (isActive !== undefined) updateData.isActive = isActive;
    if (isFavorite !== undefined) updateData.isFavorite = isFavorite;

    const product = await prisma.product.update({
      where: { id },
      data: updateData,
      include: {
        category: true,
      },
    });

    res.json({ message: '√úr√ºn ba≈üarƒ±yla g√ºncellendi', product });
  } catch (error) {
    console.error('Update product error:', error);
    res.status(500).json({ error: '√úr√ºn g√ºncellenemedi' });
  }
};

export const deleteProduct = async (req: Request, res: Response) => {
  try {
    const { id } = req.params;

    // Check if product has ANY related records
    const saleItems = await prisma.saleItem.count({ where: { productId: id } });
    const stockCountItems = await prisma.stockCountItem.count({ where: { productId: id } });
    const stockMovements = await prisma.stockMovement.count({ where: { productId: id } });
    const productVariants = await prisma.productVariant.count({ where: { productId: id } });
    const purchaseOrderItems = await prisma.purchaseOrderItem.count({ where: { productId: id } });
    
    const hasRelations = saleItems > 0 || stockCountItems > 0 || stockMovements > 0 || 
                        productVariants > 0 || purchaseOrderItems > 0;
    
    if (hasRelations) {
      // Soft delete: Just deactivate the product instead of deleting
      await prisma.product.update({
        where: { id },
        data: { isActive: false },
      });
      
      res.json({ 
        message: '√úr√ºn devre dƒ±≈üƒ± bƒ±rakƒ±ldƒ± (ili≈ükili kayƒ±tlar olduƒüu i√ßin silinemez)', 
        softDelete: true 
      });
    } else {
      // No related records, safe to delete
      await prisma.product.delete({
        where: { id },
      });
      
      res.json({ message: '√úr√ºn ba≈üarƒ±yla silindi' });
    }
  } catch (error) {
    console.error('Delete product error:', error);
    res.status(500).json({ error: '√úr√ºn silinemedi' });
  }
};

export const bulkDeleteProducts = async (req: Request, res: Response) => {
  try {
    const { ids } = req.body;

    if (!ids || !Array.isArray(ids) || ids.length === 0) {
      return res.status(400).json({ error: 'Silinecek √ºr√ºn ID\'leri gerekli' });
    }

    const result = await prisma.product.deleteMany({
      where: {
        id: {
          in: ids,
        },
      },
    });

    res.json({ 
      message: `${result.count} √ºr√ºn ba≈üarƒ±yla silindi`,
      count: result.count,
    });
  } catch (error) {
    console.error('Bulk delete products error:', error);
    res.status(500).json({ error: '√úr√ºnler silinemedi' });
  }
};

export const getLowStockProducts = async (req: Request, res: Response) => {
  try {
    const products = await prisma.product.findMany({
      where: {
        stock: {
          lte: prisma.product.fields.minStock,
        },
        isActive: true,
      },
      include: {
        category: true,
      },
      orderBy: {
        stock: 'asc',
      },
    });

    res.json({ products });
  } catch (error) {
    console.error('Get low stock products error:', error);
    res.status(500).json({ error: 'D√º≈ü√ºk stoklu √ºr√ºnler getirilemedi' });
  }
};

// Bulk Import/Upsert - Toplu √ºr√ºn ekleme/g√ºncelleme (HIZLI!)
export const bulkUpsertProducts = async (req: Request, res: Response) => {
  try {
    const { products } = req.body;

    if (!products || !Array.isArray(products) || products.length === 0) {
      return res.status(400).json({ error: '√úr√ºn listesi gerekli' });
    }

    let addedCount = 0;
    let updatedCount = 0;
    const errors: any[] = [];

    // Transaction OLMADAN (daha hƒ±zlƒ± ve timeout yok!)
    // Her √ºr√ºn√º paralel olarak i≈üle (Promise.all ile)
    const batchPromises = products.map(async (productData) => {
      try {
        // Barkoda g√∂re √ºr√ºn ara
        const existingProduct = productData.barcode
          ? await prisma.product.findFirst({
              where: { barcode: productData.barcode },
            })
          : null;

        if (existingProduct) {
          // G√úNCELLE
          await prisma.product.update({
            where: { id: existingProduct.id },
            data: {
              name: productData.name,
              sellPrice: productData.sellPrice || productData.price,
              buyPrice: productData.buyPrice || productData.cost,
              stock: productData.stock,
              unit: productData.unit || 'ADET',
              taxRate: productData.taxRate || 18,
              minStock: productData.minStock || 5,
              description: productData.description,
              ...(productData.categoryId && { categoryId: productData.categoryId }),
            },
          });
          return { type: 'updated' };
        } else {
          // YENƒ∞ EKLE
          await prisma.product.create({
            data: {
              barcode: productData.barcode || generateEAN13(),
              name: productData.name,
              sellPrice: productData.sellPrice || productData.price,
              buyPrice: productData.buyPrice || productData.cost || 0,
              stock: productData.stock || 0,
              unit: productData.unit || 'ADET',
              taxRate: productData.taxRate || 18,
              minStock: productData.minStock || 5,
              description: productData.description || '',
              isActive: true,
              ...(productData.categoryId && { categoryId: productData.categoryId }),
            },
          });
          return { type: 'added' };
        }
      } catch (itemError: any) {
        errors.push({
          product: productData.name,
          error: itemError.message,
        });
        return { type: 'error' };
      }
    });

    // T√ºm i≈ülemleri paralel √ßalƒ±≈ütƒ±r
    const results = await Promise.all(batchPromises);
    
    // Sonu√ßlarƒ± say
    results.forEach(result => {
      if (result.type === 'added') addedCount++;
      if (result.type === 'updated') updatedCount++;
    });

    res.json({
      success: true,
      message: `${addedCount} √ºr√ºn eklendi, ${updatedCount} √ºr√ºn g√ºncellendi`,
      added: addedCount,
      updated: updatedCount,
      errors: errors.length > 0 ? errors : undefined,
    });
  } catch (error: any) {
    console.error('Bulk upsert products error:', error);
    res.status(500).json({ error: 'Toplu √ºr√ºn i≈ülemi ba≈üarƒ±sƒ±z: ' + error.message });
  }
};

// üåü FAVORƒ∞ √úR√úN TOGGLE
export const toggleFavorite = async (req: Request, res: Response) => {
  try {
    const { id } = req.params;

    const product = await prisma.product.findUnique({
      where: { id },
    });

    if (!product) {
      return res.status(404).json({ error: '√úr√ºn bulunamadƒ±' });
    }

    const updatedProduct = await prisma.product.update({
      where: { id },
      data: {
        isFavorite: !product.isFavorite,
      },
      include: {
        category: true,
      },
    });

    res.json({
      success: true,
      isFavorite: updatedProduct.isFavorite,
      message: updatedProduct.isFavorite ? '‚ù§Ô∏è Favorilere eklendi!' : 'üíî Favorilerden √ßƒ±karƒ±ldƒ±',
      product: updatedProduct,
    });
  } catch (error) {
    console.error('Toggle favorite error:', error);
    res.status(500).json({ error: 'Favori durumu deƒüi≈ütirilemedi' });
  }
};

// üåü FAVORƒ∞ √úR√úNLERƒ∞ GETƒ∞R
export const getFavoriteProducts = async (req: Request, res: Response) => {
  try {
    const products = await prisma.product.findMany({
      where: {
        isFavorite: true,
        isActive: true, // Sadece aktif favoriler
      },
      include: {
        category: true,
      },
      orderBy: {
        name: 'asc', // Alfabetik sƒ±ralama
      },
    });

    res.json({ 
      products,
      count: products.length 
    });
  } catch (error) {
    console.error('Get favorite products error:', error);
    res.status(500).json({ error: 'Favori √ºr√ºnler getirilemedi' });
  }
};

// Excel/CSV ile Toplu √úr√ºn ƒ∞√ße Aktarma
export const bulkImportProducts = async (req: Request, res: Response) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'Dosya y√ºklenmedi' });
    }

    // Excel dosyasƒ±nƒ± parse et
    const workbook = XLSX.read(req.file.buffer, { type: 'buffer' });
    const sheetName = workbook.SheetNames[0];
    const worksheet = workbook.Sheets[sheetName];
    
    // JSON'a √ßevir (header: 1 ile array olarak al - ba≈ülƒ±k olup olmadƒ±ƒüƒ±na bakmaksƒ±zƒ±n)
    const rawData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' });

    if (rawData.length === 0) {
      return res.status(400).json({ error: 'Excel dosyasƒ± bo≈ü' });
    }

    // ƒ∞lk satƒ±r ba≈ülƒ±k mƒ± yoksa data mƒ± kontrol et
    const firstRow: any = rawData[0];
    const hasHeaders = 
      typeof firstRow[0] === 'string' && 
      (firstRow[0].toLowerCase().includes('barkod') || 
       firstRow[1].toLowerCase().includes('√ºr√ºn') ||
       firstRow[1].toLowerCase().includes('ad'));

    // Ba≈ülƒ±k varsa 2. satƒ±rdan ba≈üla, yoksa 1. satƒ±rdan
    const startRow = hasHeaders ? 1 : 0;

    // Ba≈üarƒ±lƒ± ve ba≈üarƒ±sƒ±z kayƒ±tlarƒ± takip et
    const results = {
      success: 0,
      updated: 0,
      created: 0,
      failed: 0,
      errors: [] as string[],
    };

    // Her satƒ±rƒ± i≈üle
    for (let i = startRow; i < rawData.length; i++) {
      const row: any = rawData[i];

      // Bo≈ü satƒ±rlarƒ± atla
      if (!row || row.every((cell: any) => !cell)) {
        continue;
      }

      try {
        // Excel s√ºtunlarƒ± - ƒ∞NDEKS BAZLI (BenimPOS formatƒ±)
        // A: √úr√ºn Barkodu, B: √úr√ºn Adƒ±, C: Adet, D: Birim, E: Fiyat 1, 
        // F: KDV, G: Alƒ±≈ü Fiyatƒ±, H: √úst Grup, I: √úr√ºn Grubu, 
        // J: Fiyat 2, K: Stok Kodu, L: √úr√ºn Detayƒ±, M: Hƒ±zlƒ± Grup, 
        // N: Sƒ±ra, O: Kritik Stok
        
        let barcode = String(row[0] || '').trim();
        const name = String(row[1] || '').trim();
        const stock = parseInt(String(row[2] || '0')) || 0;
        const unit = String(row[3] || 'ADET').trim();
        const sellPrice = parseFloat(String(row[4] || '0')) || 0;
        const taxRate = parseFloat(String(row[5] || '18')) || 18;
        const buyPrice = parseFloat(String(row[6] || '0')) || 0;
        const categoryName = String(row[8] || '').trim(); // I s√ºtunu (√úr√ºn Grubu)
        const sku = String(row[10] || '').trim(); // K s√ºtunu
        const description = String(row[11] || '').trim(); // L s√ºtunu
        const minStock = parseInt(String(row[14] || '5')) || 5; // O s√ºtunu

        // üßπ BARKOD TEMƒ∞ZLƒ∞ƒûƒ∞ - Ba≈üƒ±ndaki/sonundaki gereksiz karakterleri kaldƒ±r
        if (barcode && typeof barcode === 'string') {
          barcode = barcode
            .trim() // Bo≈üluklarƒ± kaldƒ±r
            .replace(/^[.,'"¬¥`\-\s]+/, '') // Ba≈üƒ±ndaki: . , ' " ¬¥ ` - bo≈üluk
            .replace(/[.,'"¬¥`\-\s]+$/, ''); // Sonundaki: . , ' " ¬¥ ` - bo≈üluk
        }

        // Validasyon
        const rowNumber = hasHeaders ? i + 1 : i + 1; // Excel satƒ±r numarasƒ± (1-based)
        
        if (!name || name === '') {
          results.errors.push(`Satƒ±r ${rowNumber}: √úr√ºn adƒ± bo≈ü olamaz (B s√ºtunu)`);
          results.failed++;
          continue;
        }

        if (sellPrice <= 0) {
          results.errors.push(`Satƒ±r ${rowNumber}: Satƒ±≈ü fiyatƒ± 0'dan b√ºy√ºk olmalƒ± (E s√ºtunu)`);
          results.failed++;
          continue;
        }

        // Kategori var mƒ± kontrol et, yoksa olu≈ütur
        let category;
        if (categoryName && categoryName.trim() !== '') {
          category = await prisma.category.findFirst({
            where: { name: categoryName.trim() },
          });

          if (!category) {
            category = await prisma.category.create({
              data: { name: categoryName.trim() },
            });
          }
        }

        // Barkod yoksa otomatik olu≈ütur
        let finalBarcode = barcode && barcode.trim() !== '' ? barcode.trim() : generateEAN13();
        
        // SKU yoksa otomatik olu≈ütur
        let finalSku = sku && sku.trim() !== '' ? sku.trim() : `SKU-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

        // Barkod zaten var mƒ± kontrol et
        const existingProduct = await prisma.product.findUnique({
          where: { barcode: finalBarcode },
        });

        if (existingProduct) {
          // Varsa g√ºncelle
          await prisma.product.update({
            where: { barcode: finalBarcode },
            data: {
              name: name.trim(),
              categoryId: category?.id,
              buyPrice,
              sellPrice,
              stock,
              minStock,
              unit,
              taxRate,
              description: description || '',
            },
          });
          results.updated++;
        } else {
          // Yoksa yeni olu≈ütur
          await prisma.product.create({
            data: {
              barcode: finalBarcode,
              sku: finalSku,
              name: name.trim(),
              categoryId: category?.id,
              buyPrice,
              sellPrice,
              stock,
              minStock,
              unit,
              taxRate,
              description: description || '',
              isActive: true,
            },
          });
          results.created++;
        }

        results.success++;
      } catch (error: any) {
        const rowNumber = hasHeaders ? i + 1 : i + 1;
        results.errors.push(`Satƒ±r ${rowNumber}: ${error.message}`);
        results.failed++;
      }
    }

    res.json({
      message: 'Toplu aktarƒ±m tamamlandƒ±',
      results,
    });
  } catch (error: any) {
    console.error('Bulk import error:', error);
    res.status(500).json({ error: error.message || 'Toplu aktarƒ±m sƒ±rasƒ±nda hata olu≈ütu' });
  }
};

// üîß TEK SEFERLƒ∞K: T√ºm stoklarƒ± 50'ye √ßek
export const resetAllStocksTo50 = async (req: Request, res: Response) => {
  try {
    const result = await prisma.product.updateMany({
      data: {
        stock: 50,
      },
    });

    res.json({
      success: true,
      message: `${result.count} √ºr√ºn√ºn stoƒüu 50'ye g√ºncellendi`,
      updatedCount: result.count,
    });
  } catch (error) {
    console.error('Reset stocks error:', error);
    res.status(500).json({ error: 'Stoklar g√ºncellenemedi' });
  }
};
